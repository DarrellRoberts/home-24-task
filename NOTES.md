## Notes

1. First I wanted to get the app running and I ran into some issues regarding the proxy-server on the package.json on the client. The issue was that an empty value was being passed to the allowedHosts on the config of the Webpack Dev Server, meaning the react-scripts couldn't start. I found the only quick solution that worked for me was removing the proxy server line from the package.json and changing the fetch url to localhost:3001. Meanwhile I added CORs to the server directory to allow my client's requests, and once I ran both my server and client, the client app ran and could fetch the data.

2. For my first task, I wanted to restructure the client to make it easier to navigate with appropriate directories. I kept the code as it was at the time and refactor the components so that it fitted within its corresponding directory. When I had finished this, I would check to make sure the app on local host looked the same as before I did the restructure. Satisfied I then moved onto changing the code.

3. The XML method of fetching data is outdated and I know there are a few alternatives I can use. I decided to use the native fetch API rather than installing a package such as Axios, as I felt it wasn't needed. I used useState and useEffect to create my own fetch hook, which meant I can move the fetching logic to a seperate function. If this project was going to be scaled significantly then I would have used Redux for state management, but I didn't see the need and it seemed a lot more efficient to use useState, given this was a small project. The GraphQL query was also very long so I decided to move it into its own directory. Both of these measures meant that on the Homepage, I can just call the custom hook to fetch data, making the component a lot cleaner.

4. After this, I replaced any instance of var, the ES5 variable, with const as it is outdated. Also as I had extracted ArticleCard into its own component, it meant I could move the formatter within the function scope, rather than it being stored globally. I also created an App.tsx component and within it rendered the HomePage component from the pages directory. This made more sense to me semantically rather than a component called ProductList.

5. I then started to think about how to improve the UX and my first thought was sorting the data. This lead me first to sort the category list in the sidebar by alphabetical order as well as sorting the product feed by price. I added other functionality such as search functionality, price filters and simple pagination.

6. It was only now that I focused on the styling of the app and I installed emotionJS. I started with the theming to ensure a consistent style across the app and created my own UI components, which I could import into my other components. I haven't used emotionJS so I relied on the documentation and used Google Gemini as a sounding board. Once comfortable with emotionJS, I browsed dribbble.com for inspiration, specifically E-commerce websites. I quite liked the color scheme of this design: https://dribbble.com/shots/25570379-Fashion-Ecommerce-Website-UIUX-Design-FitFlux, and I based my color scheme on that. I defined my primary, secondary and background colors among others such as background-accented. I also decided on the fonts I wanted to use and I liked the mixture of the modern look of Poppins with the slightly luxurious Playfair.

7. After I had establised the look of my main theme, I worked on the UI components with the ProductGrid being the most important. I tested different column sizes as well as its responsiveness and my aim was to write as few media queries as possible. For the grid to be effective, I knew also that the Card component was important. I made sure with the Card, for example, that I assigned appropriate props. Although I've never created my own component library before, I have experience with many, such as: Ant Design, Tailwind CSS, Hero UI and Nuxt UI. Therefore, I knew what was needed for the base components so to speak.

8. When I had my UI components, I fed them into the application where appropriate. After I was satisfied, I spent a while testing again the responsiveness and adjusted if needed.

9. By this point, my app was looking how I wanted but I realised also that although I had used emotionJS, I had not used the styled system. Its documentation is a bit hidden as its original domain: https://styled-system.com/ seems to talk mostly about Casino alternatives. Nonetheless, I played around with styled systems and emotionJS, and used Google Gemini to bring me up to speed on the process of creating primitives. By this point, I felt confidant to refactor my previous styling (using only the emotion css property) into styled system components that use primitives. Throughout the process I made use of Git for version control, and for this step I decided to create another branch so that my previous work wouldn't be affected if something went wrong.

10. It took me a while to refactor the styling and I often came into conflicts whereby my original styling had been lost. I first tried to make use of AI to help with the refactor, and it did help in some respects, though it reached a point where it would hallucinate or add its own stylings, which led me to abandon the approach. Also I had difficulty with some components transitioning from the css property to styled system syntax. In the interest of time, I moved on as I didn't want to dwell on it.

11. At this stage it was my last day and I added some finishing touches, as well as fixed various bugs or responsiveness issues. One UX feature I really like is when the user clicks on the searchbar, everything outside of the component becomes blurred, forcing the user to focus on the search input.

12. When satisfied with my app, I turned towards testing. I did not have much time at this point so I used AI to help me generate some Jest unit tests, which required tweaking on my part such as adding dataIds to the relevant tags. I also installed Playwright for e2e testing. This was a new testing library for me, having used Cypress before, so I also used AI to speed up the process in interest of time. Once I had created my tests, on seperate branches, and they passed, I pushed and merged them to main.

13. After this, I felt proud of my project and I felt that I did not have enough time to create more tests and develop new features. Hence, after updating my Notes and TODO, I submitted the project.
